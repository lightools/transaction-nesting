<?php

namespace Lightools\TransactionNesting;

use DibiConnection;
use DibiEvent;
use Exception;
use InvalidArgumentException;

/**
 * @author Jan Nedbal
 */
class TransactionManager {

    /**
     * Apply isolation on next transaction (not started yet)
     */
    const ISOLATE_NEXT_TRANSACTION = '';

    /**
     * Apply isolation on current session
     */
    const ISOLATE_SESSION = 'SESSION';

    /**
     * Phantoms, dirty-read and non-repeatable reads can occur
     */
    const ISOLATION_READ_UNCOMMITTED = 'READ UNCOMMITTED';

    /**
     * Phantoms and non-repeatable reads can occur
     */
    const ISOLATION_READ_COMMITTED = 'READ COMMITTED';

    /**
     * Phantoms can occur
     */
    const ISOLATION_REPEATABLE_READ = 'REPEATABLE READ';

    /**
     * No anomaly can occur
     */
    const ISOLATION_SERIALIZABLE = 'SERIALIZABLE';

    /**
     * Available isolation modes
     * @var array
     */
    private $isolationModes = [
        self::ISOLATE_NEXT_TRANSACTION,
        self::ISOLATE_SESSION,
    ];

    /**
     * Available isolation levels
     * @var array
     */
    private $isolationLevels = [
        self::ISOLATION_READ_UNCOMMITTED,
        self::ISOLATION_READ_COMMITTED,
        self::ISOLATION_REPEATABLE_READ,
        self::ISOLATION_SERIALIZABLE,
    ];

    /**
     * @var DibiConnection
     */
    private $dibi;

    /**
     * Is transaction running on $dibi connection?
     * - is trusthworthy if no queries, which cause implicit commit are done between beginning and committing
     * @var bool
     */
    private $someTransactionRunning = FALSE;


    /**
     * Transactions in format: transactionId => (bool) started?
     * @var bool[]
     */
    private $transactions = [];

    /**
     * @param DibiConnection $dibi
     */
    public function __construct(DibiConnection $dibi) {
        $this->dibi = $dibi;
        $this->dibi->onEvent[] = function (DibiEvent $event) {
            $this->setupTransactionStatus($event);
        };
    }

    /**
     * Perform given callback within transaction and rollback when any exception occurs
     * @param callable $function
     * @return mixed Returns what function returned
     * @throws Exception
     */
    public function transactional(callable $function) {
        $id = $this->begin();
        try {
            $return = $function();
            $this->commit($id);
            return $return;

        } catch (Exception $ex) {
            $this->rollback($id);
            throw $ex;
        }
    }

    /**
     * Begin transaction if not started before
     * @return string Generated transaction id
     */
    public function begin() {

        if (!$this->someTransactionRunning) {
            $this->dibi->begin();
            $started = TRUE;
        } else {
            $started = FALSE;
        }

        do {
            $transactionId = uniqid();
        } while (isset($this->transactions[$transactionId]));

        $this->transactions[$transactionId] = $started;

        return $transactionId;
    }

    /**
     * Commit transaction if started before
     * @param string $transactionId Transaction id generated by beginTransaction() method
     * @return boolean Committed given transaction?
     */
    public function commit($transactionId) {

        if (!isset($this->transactions[$transactionId])) {
            throw new InvalidArgumentException("Invalid transaction id '$transactionId', no such transaction ever started");

        } elseif ($this->transactions[$transactionId]) {
            $this->dibi->commit();
            $commited = TRUE;
        } else {
            $commited = FALSE;
        }

        return $commited;
    }

    /**
     * Rollback transaction if running
     * @param string $transactionId Transaction id generated by beginTransaction() method
     * @return boolean Rollbacked given transaction?
     */
    public function rollback($transactionId) {
        if (!isset($this->transactions[$transactionId])) {
            throw new InvalidArgumentException("Invalid transaction id '$transactionId', no such transaction ever started");

        } elseif ($this->transactions[$transactionId]) {
            $this->dibi->rollback();
            $rollbacked = TRUE;
        } else {
            $rollbacked = FALSE;
        }

        return $rollbacked;
    }

    /**
     * Had transaction with transactionId started?
     * @param string $transactionId Transaction id generated by beginTransaction method
     * @return bool
     */
    public function isTransactionStarted($transactionId) {
        return isset($this->transactions[$transactionId]) && $this->transactions[$transactionId];
    }

    /**
     * @return string self::ISOLATION_*
     */
    public function getIsolationLevel() {
        // query returns REPEATABLE-READ, but for setting this value is needed REPEATABLE READ as defined in self::ISOLATION_REPEATABLE_READ
        return str_replace('-', ' ', $this->dibi->query('SELECT @@tx_isolation')->fetchSingle());
    }

    /**
     * @param string $level self::ISOLATION_*
     * @param string $isolationMode self::ISOLATE_*
     */
    public function setIsolationLevel($level, $isolationMode = self::ISOLATE_NEXT_TRANSACTION) {

        if (!in_array($level, $this->isolationLevels)) {
            throw new InvalidArgumentException('Invalid isolation level, please use ' . __CLASS__ . '::ISOLATION_* constant.');
        }

        if (!in_array($isolationMode, $this->isolationModes)) {
            throw new InvalidArgumentException('Invalid isolation mode, please use ' . __CLASS__ . '::ISOLATE_* constant.');
        }

        $this->dibi->query("SET $isolationMode TRANSACTION ISOLATION LEVEL $level");
    }

    /**
     * @param DibiEvent $event
     */
    private function setupTransactionStatus(DibiEvent $event) {
        if ($event->type === DibiEvent::BEGIN) {
            $this->someTransactionRunning = TRUE;
        }

        if ($event->type === DibiEvent::COMMIT || $event->type === DibiEvent::ROLLBACK) {
            $this->someTransactionRunning = FALSE;
        }
    }

}
